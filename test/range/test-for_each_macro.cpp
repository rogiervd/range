/*
Copyright 2013, 2014 Rogier van Dalen.

This file is part of Rogier van Dalen's Range library for C++.

This library is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/** \file
Test the RANGE_FOR_EACH macro.
*/

#define BOOST_TEST_MODULE test_range_for_each_macro
#include "utility/test/boost_unit_test.hpp"

#include <iostream>
#include "range/for_each_macro.hpp"

#include "range/std.hpp"
#include "range/function_range.hpp"

#include <vector>

BOOST_AUTO_TEST_SUITE(test_range_for_each_macro)

bool is_rvalue_reference (int &&) { return true; }
bool is_rvalue_reference (int const &) { return false; }

BOOST_AUTO_TEST_CASE (test_example) {

    using range::view;
    using range::empty;
    using range::drop;
    using range::first;

    std::vector <int> is;
    is.push_back (1);
    is.push_back (0); // Do not break.
    is.push_back (2);
    is.push_back (-100); // Skip.
    is.push_back (4);
    is.push_back (8);
    is.push_back (16); // Break after this.
    is.push_back (32);

    {
        int i = 5;
        auto && i2 = 5;

        BOOST_CHECK_EQUAL (i2, 5);

        // The declared type of i2 is int &&.
        BOOST_MPL_ASSERT ((std::is_same <decltype (i2), int &&>));

        BOOST_CHECK (!is_rvalue_reference (i));
        // Since i2 has a name, it is not an rvalue reference here.
        BOOST_CHECK (!is_rvalue_reference (i2));
        // But it can be explicitly cast to an rvalue reference.
        BOOST_CHECK (is_rvalue_reference (static_cast <decltype (i2)> (i2)));
    }

    // This is what we'd like to do.
    // This tests "continue" and "break".
    {
        int total = 0;
        // Start meaning of code generated by FOREACH (element, is).
        for (auto v = view (is); !empty (v); v = drop (v))
        {
            decltype (first (v)) element = first (v);
            // End code meaning of generated by FOREACH (element, is).

            if (element < 0)
                continue;
            total += element;
            if (element == 8)
                element = -8;
            if (element == 16)
                break;
        }

        BOOST_CHECK_EQUAL (total, 31);
        BOOST_CHECK_EQUAL (is [5], -8);
    }

    // Reset.
    is [5] = 8;

    // This shows how the macro works.
    {
        int total = 0;

        /*
        We would like to declare scoped variables, but we can't use braces.
        We can therefore use a for-loop:
            for (Type variable = ...; ? ; ? )
        but what to put in the second field to make sure it gets executed only
        once?
        We need a boolean that is false the first time around and gets set to
        true the next time.
        This does the job:
            if (bool done = false)
                for (Type variable = ...; !done; done = true)
        The "if (false) else" construction makes sure that when RANGE_FOR_EACH
        is used in an if-else statement, the else part gets executed correctly.
        */

        if (bool done = false) {} else
        // This for-loop defines a variable "sequence" which holds a reference
        // (an lvalue or rvalue reference, as appropriate) to the sequence.
        // This makes sure the sequence does not prematurely disappear from
        // memory.
        for (auto && sequence = is; !done; done = true)
        // The boolean "seen" seems silly, but it serves two purposes:
        //  1.  The inner for loop is to give the variable "element" scope.
        //  2.  If there is a "break" statement, the variable will have an
        //      unexpected value, which signals that the loop can be aborted.
        if (bool seen = false) {} else
        for (
            auto v = range::view (static_cast <decltype (sequence)> (sequence));
                !range::empty (v); seen = !seen)
            if (seen)
        // This can only happen if the inner loop has hit a "break".
                break;
            else
        // Declare a variable of the type that range::chop_in_place (v) returns.
        // "auto &&" binds correctly to all kinds of types: lvalue or rvalue,
        // qualified or not.
                for (auto && element = range::chop_in_place (v);
                        !seen; seen = true)
        // Inner loop, user-provided:
                {
                    if (element < 0)
                        continue;
                    total += element;
                    if (element == 8)
                        element = -8;
                    if (element == 16)
                        break;
                }

        BOOST_CHECK_EQUAL (total, 31);
        BOOST_CHECK_EQUAL (is [5], -8);
    }
}

std::vector <int> longer_and_longer() {
    static std::vector <int> i;
    i.push_back (4);
    return i;
}

std::vector <int> & longer_and_longer_reference() {
    static std::vector <int> i;
    i.push_back (5);
    return i;
}

std::vector <int> const & longer_and_longer_const_reference() {
    static std::vector <int> i;
    i.push_back (5);
    return i;
}

bool is_const (int &) { return false; }
bool is_const (int const &) { return true; }

BOOST_AUTO_TEST_CASE (test_macro) {
    std::vector <int> is;
    is.push_back (1);
    is.push_back (0); // Do not break.
    is.push_back (2);
    is.push_back (-100); // Skip.
    is.push_back (4);
    is.push_back (8);
    is.push_back (16); // Break after this.
    is.push_back (32);

    // The example above.
    {
        int total = 0;
        RANGE_FOR_EACH (element, is) {
            // Test "continue".
            if (element < 0)
                continue;
            total += element;
            // Test mutability
            if (element == 8)
                element = -8;
            // Test "break".
            if (element == 16)
                break;
        }

        BOOST_CHECK_EQUAL (total, 31);
        BOOST_CHECK_EQUAL (is [5], -8);
        // Reset
        is [5] = 8;
    }

    // Without braces.
    {
        int total = 0;
        RANGE_FOR_EACH (element, is)
            total += element;

        BOOST_CHECK_EQUAL (total, 63 - 100);
    }

    // Nested and without braces.
    {
        std::vector <int> is2;
        is2.push_back (5);
        is2.push_back (7);
        int total = 0;
        RANGE_FOR_EACH (element2, is2)
            RANGE_FOR_EACH (element, is)
                total += element2 * element;

        BOOST_CHECK_EQUAL (total, (5 + 7) * (63 - 100));
    }

    // A function must be called only once.
    // The return value must hang around during the for loop, though!
    {
        std::size_t size = range::size (longer_and_longer());
        BOOST_CHECK_EQUAL (size, 1u);
        size = range::size (longer_and_longer());
        BOOST_CHECK_EQUAL (size, 2u);

        size_t sum = 0;
        RANGE_FOR_EACH (i, longer_and_longer()) {
            sum += i;
            // Even though the sequence is held internally with an rvalue
            // reference, since it is named, it should be an lvalue.
            // So its elements should be lvalues.
            static_assert (std::is_reference <decltype (i)>::value, "");
        }
        BOOST_CHECK_EQUAL (sum, 12);

        sum = 0;
        RANGE_FOR_EACH (i, longer_and_longer())
            sum += i;
        BOOST_CHECK_EQUAL (sum, 16);
    }

    // Function that returns a reference.
    {
        std::size_t size = range::size (longer_and_longer_reference());
        BOOST_CHECK_EQUAL (size, 1u);
        size = range::size (longer_and_longer_reference());
        BOOST_CHECK_EQUAL (size, 2u);

        size_t sum = 0;
        RANGE_FOR_EACH (i, longer_and_longer_reference())
            sum += i;
        BOOST_CHECK_EQUAL (sum, 15);

        sum = 0;
        RANGE_FOR_EACH (i, longer_and_longer_reference())
            sum += i;
        BOOST_CHECK_EQUAL (sum, 20);
    }

    // Const-ness
    {
        RANGE_FOR_EACH (i, is) {
            BOOST_CHECK (!is_const (i));
        }
        RANGE_FOR_EACH (i, longer_and_longer()) {
            BOOST_CHECK (is_const (i));
        }
        RANGE_FOR_EACH (i, longer_and_longer_reference()) {
            BOOST_CHECK (!is_const (i));
        }
        RANGE_FOR_EACH (i, longer_and_longer_const_reference()) {
            BOOST_CHECK (is_const (i));
        }
    }

    // Embed RANGE_FOR_EACH in an if-else.
    {
        bool if_false_else_executed = false;
        if (false)
            RANGE_FOR_EACH (dummy, is) {
                BOOST_CHECK (dummy != dummy);
            }
        else {
            if_false_else_executed = true;
        }
        BOOST_CHECK (if_false_else_executed);
    }
}

struct next_integer {
    int i;
    next_integer() : i (0) {}
    int operator() () { return i ++; }
};

BOOST_AUTO_TEST_CASE (test_input_range) {
    auto range = range::make_function_range (next_integer());
    int first = range::chop_in_place (range);
    BOOST_CHECK_EQUAL (first, 0);
    int second = range::chop_in_place (range);
    BOOST_CHECK_EQUAL (second, 1);

    int total = 0;
    BOOST_MPL_ASSERT ((std::is_same <
        decltype (range::forward_view (std::move (range))),
        decltype (std::move (range))>));
    RANGE_FOR_EACH (n, std::move (range)) {
        total += n;
        if (n == 10)
            break;
    }
    BOOST_CHECK_EQUAL (total, 2+3+4+5+6+7+8+9+10);
}

BOOST_AUTO_TEST_SUITE_END()

